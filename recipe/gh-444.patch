diff --git a/CMake/FindGMP.cmake b/CMake/FindGMP.cmake
new file mode 100644
index 000000000..e6e39ce9d
--- /dev/null
+++ b/CMake/FindGMP.cmake
@@ -0,0 +1,75 @@
+# Try to find the GMP library
+# https://gmplib.org/
+#
+# This module supports requiring a minimum version, e.g. you can do
+#   find_package(GMP 6.0.0)
+# to require version 6.0.0 to newer of GMP.
+#
+# Once done this will define
+#
+#  GMP_FOUND - system has GMP lib with correct version
+#  GMP_INCLUDE_DIRS - the GMP include directory
+#  GMP_LIBRARIES - the GMP library
+#  GMP_VERSION - GMP version
+#
+# Copyright (c) 2016 Jack Poulson, <jack.poulson@gmail.com>
+# Redistribution and use is allowed according to the terms of the BSD license.
+
+find_path(GMP_INCLUDE_DIRS NAMES gmp.h PATHS $ENV{GMPDIR} ${INCLUDE_INSTALL_DIR})
+
+# Set GMP_FIND_VERSION to 5.1.0 if no minimum version is specified
+if(NOT GMP_FIND_VERSION)
+  if(NOT GMP_FIND_VERSION_MAJOR)
+    set(GMP_FIND_VERSION_MAJOR 5)
+  endif()
+  if(NOT GMP_FIND_VERSION_MINOR)
+    set(GMP_FIND_VERSION_MINOR 1)
+  endif()
+  if(NOT GMP_FIND_VERSION_PATCH)
+    set(GMP_FIND_VERSION_PATCH 0)
+  endif()
+  set(GMP_FIND_VERSION
+    "${GMP_FIND_VERSION_MAJOR}.${GMP_FIND_VERSION_MINOR}.${GMP_FIND_VERSION_PATCH}")
+endif()
+
+if(GMP_INCLUDE_DIRS)
+  # Since the GMP version macros may be in a file included by gmp.h of the form
+  # gmp-.*[_]?.*.h (e.g., gmp-x86_64.h), we search each of them.
+  file(GLOB GMP_HEADERS "${GMP_INCLUDE_DIRS}/gmp.h" "${GMP_INCLUDE_DIRS}/gmp-*.h")
+  foreach(gmp_header_filename ${GMP_HEADERS})
+    file(READ "${gmp_header_filename}" _gmp_version_header)
+    string(REGEX MATCH
+      "define[ \t]+__GNU_MP_VERSION[ \t]+([0-9]+)" _gmp_major_version_match
+      "${_gmp_version_header}")
+    if(_gmp_major_version_match)
+      set(GMP_MAJOR_VERSION "${CMAKE_MATCH_1}")
+      string(REGEX MATCH "define[ \t]+__GNU_MP_VERSION_MINOR[ \t]+([0-9]+)"
+        _gmp_minor_version_match "${_gmp_version_header}")
+      set(GMP_MINOR_VERSION "${CMAKE_MATCH_1}")
+      string(REGEX MATCH "define[ \t]+__GNU_MP_VERSION_PATCHLEVEL[ \t]+([0-9]+)"
+        _gmp_patchlevel_version_match "${_gmp_version_header}")
+      set(GMP_PATCHLEVEL_VERSION "${CMAKE_MATCH_1}")
+      set(GMP_VERSION
+        ${GMP_MAJOR_VERSION}.${GMP_MINOR_VERSION}.${GMP_PATCHLEVEL_VERSION})
+    endif()
+  endforeach()
+
+  # Check whether found version exists and exceeds the minimum requirement
+  if(NOT GMP_VERSION)
+    set(GMP_VERSION_OK FALSE)
+    message(STATUS "GMP version was not detected")
+  elseif(${GMP_VERSION} VERSION_LESS ${GMP_FIND_VERSION})
+    set(GMP_VERSION_OK FALSE)
+    message(STATUS "GMP version ${GMP_VERSION} found in ${GMP_INCLUDE_DIRS}, "
+                   "but at least version ${GMP_FIND_VERSION} is required")
+  else()
+    set(GMP_VERSION_OK TRUE)
+  endif()
+endif()
+
+find_library(GMP_LIBRARIES gmp PATHS $ENV{GMPDIR} ${LIB_INSTALL_DIR})
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(GMP DEFAULT_MSG
+                                  GMP_INCLUDE_DIRS GMP_LIBRARIES GMP_VERSION_OK)
+mark_as_advanced(GMP_INCLUDE_DIRS GMP_LIBRARIES)
\ No newline at end of file
diff --git a/CMake/FindMPFR.cmake b/CMake/FindMPFR.cmake
new file mode 100644
index 000000000..499723af7
--- /dev/null
+++ b/CMake/FindMPFR.cmake
@@ -0,0 +1,72 @@
+# Try to find the MPFR library
+# See http://www.mpfr.org/
+#
+# This module supports requiring a minimum version, e.g. you can do
+#   find_package(MPFR 2.3.0)
+# to require version 2.3.0 to newer of MPFR.
+#
+# Once done this will define
+#
+#  MPFR_FOUND - system has MPFR lib with correct version
+#  MPFR_INCLUDE_DIRS - the MPFR include directory
+#  MPFR_LIBRARIES - the MPFR library
+#  MPFR_VERSION - MPFR version
+
+# Copyright (c) 2006, 2007 Montel Laurent, <montel@kde.org>
+# Copyright (c) 2008, 2009 Gael Guennebaud, <g.gael@free.fr>
+# Copyright (c) 2010 Jitse Niesen, <jitse@maths.leeds.ac.uk>
+# Copyright (c) 2015 Jack Poulson, <jack.poulson@gmail.com>
+# Redistribution and use is allowed according to the terms of the BSD license.
+
+find_path(MPFR_INCLUDE_DIRS NAMES mpfr.h PATHS $ENV{GMPDIR} $ENV{MPFRDIR}
+  ${INCLUDE_INSTALL_DIR})
+
+# Set MPFR_FIND_VERSION to 1.0.0 if no minimum version is specified
+if(NOT MPFR_FIND_VERSION)
+  if(NOT MPFR_FIND_VERSION_MAJOR)
+    set(MPFR_FIND_VERSION_MAJOR 1)
+  endif()
+  if(NOT MPFR_FIND_VERSION_MINOR)
+    set(MPFR_FIND_VERSION_MINOR 0)
+  endif()
+  if(NOT MPFR_FIND_VERSION_PATCH)
+    set(MPFR_FIND_VERSION_PATCH 0)
+  endif()
+  set(MPFR_FIND_VERSION
+    "${MPFR_FIND_VERSION_MAJOR}.${MPFR_FIND_VERSION_MINOR}.${MPFR_FIND_VERSION_PATCH}")
+endif()
+
+if(MPFR_INCLUDE_DIRS)
+  # Query MPFR_VERSION
+  file(READ "${MPFR_INCLUDE_DIRS}/mpfr.h" _mpfr_version_header)
+
+  string(REGEX MATCH "define[ \t]+MPFR_VERSION_MAJOR[ \t]+([0-9]+)"
+    _mpfr_major_version_match "${_mpfr_version_header}")
+  set(MPFR_MAJOR_VERSION "${CMAKE_MATCH_1}")
+  string(REGEX MATCH "define[ \t]+MPFR_VERSION_MINOR[ \t]+([0-9]+)"
+    _mpfr_minor_version_match "${_mpfr_version_header}")
+  set(MPFR_MINOR_VERSION "${CMAKE_MATCH_1}")
+  string(REGEX MATCH "define[ \t]+MPFR_VERSION_PATCHLEVEL[ \t]+([0-9]+)"
+    _mpfr_patchlevel_version_match "${_mpfr_version_header}")
+  set(MPFR_PATCHLEVEL_VERSION "${CMAKE_MATCH_1}")
+
+  set(MPFR_VERSION
+    ${MPFR_MAJOR_VERSION}.${MPFR_MINOR_VERSION}.${MPFR_PATCHLEVEL_VERSION})
+
+  # Check whether found version exceeds minimum required
+  if(${MPFR_VERSION} VERSION_LESS ${MPFR_FIND_VERSION})
+    set(MPFR_VERSION_OK FALSE)
+    message(STATUS "MPFR version ${MPFR_VERSION} found in ${MPFR_INCLUDE_DIRS}, "
+                   "but at least version ${MPFR_FIND_VERSION} is required")
+  else()
+    set(MPFR_VERSION_OK TRUE)
+  endif()
+endif()
+
+find_library(MPFR_LIBRARIES mpfr
+  PATHS $ENV{GMPDIR} $ENV{MPFRDIR} ${LIB_INSTALL_DIR})
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(MPFR DEFAULT_MSG
+                                  MPFR_INCLUDE_DIRS MPFR_LIBRARIES MPFR_VERSION_OK)
+mark_as_advanced(MPFR_INCLUDE_DIRS MPFR_LIBRARIES)
\ No newline at end of file
diff --git a/CMake/FindPThreads.cmake b/CMake/FindPThreads.cmake
new file mode 100644
index 000000000..3b3d2ecf0
--- /dev/null
+++ b/CMake/FindPThreads.cmake
@@ -0,0 +1,17 @@
+# Try to find the PThreads librairies
+# PThreads_FOUND - system has PThreads lib
+# PThreads_INCLUDE_DIRS - the PThreads include directory
+# PThreads_LIBRARIES - Libraries needed to use PThreads
+
+if (PThreads_INCLUDE_DIR AND PThreads_LIBRARIES)
+		# Already in cache, be silent
+		set(PThreads_FIND_QUIETLY TRUE)
+endif (PThreads_INCLUDE_DIR AND PThreads_LIBRARIES)
+
+find_path(PThreads_INCLUDE_DIR NAMES pthread.h )
+find_library(PThreads_LIBRARIES NAMES pthreads libpthreads )
+
+include(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(PThreads DEFAULT_MSG PThreads_INCLUDE_DIR PThreads_LIBRARIES)
+
+mark_as_advanced(PThreads_INCLUDE_DIR PThreads_LIBRARIES)
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 000000000..72cc585c1
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,267 @@
+cmake_minimum_required(VERSION 3.9)
+
+include(CheckIPOSupported)
+include(CheckIncludeFiles)
+include(CheckFunctionExists)
+include(CheckPrototypeDefinition)
+include(TestBigEndian)
+
+project(flint C)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
+find_package(GMP REQUIRED)
+find_package(MPFR REQUIRED)
+find_package(PythonInterp REQUIRED)
+
+if(MSVC)
+    find_package(PThreads REQUIRED)
+endif()
+
+# Find sources
+
+set(BUILD_DIRS
+    aprcl ulong_extras long_extras perm fmpz fmpz_vec fmpz_poly 
+    fmpq_poly fmpz_mat fmpz_lll mpfr_vec mpfr_mat mpf_vec mpf_mat nmod_vec nmod_poly 
+    nmod_poly_factor arith mpn_extras nmod_mat fmpq fmpq_vec fmpq_mat padic 
+    fmpz_poly_q fmpz_poly_mat nmod_poly_mat fmpz_mod_poly 
+    fmpz_mod_poly_factor fmpz_factor fmpz_poly_factor fft qsieve 
+    double_extras d_vec d_mat padic_poly padic_mat qadic  
+    fq fq_vec fq_mat fq_poly fq_poly_factor
+    fq_nmod fq_nmod_vec fq_nmod_mat fq_nmod_poly fq_nmod_poly_factor 
+    fq_zech fq_zech_vec fq_zech_mat fq_zech_poly fq_zech_poly_factor 
+    mpoly fmpz_mpoly
+)
+
+set(TEMPLATE_DIRS
+    fq_vec_templates fq_mat_templates fq_poly_templates
+    fq_poly_factor_templates fq_templates
+)
+
+set(SOURCES
+    printf.c fprintf.c sprintf.c scanf.c fscanf.c sscanf.c clz_tab.c
+    memory_manager.c version.c profiler.c thread_support.c exception.c
+    hashmap.c inlines.c fmpz/fmpz.c
+)
+
+set(HEADERS
+    NTL-interface.h flint.h longlong.h config.h gmpcompat.h fft_tuning.h
+    fmpz-conversions.h profiler.h templates.h exception.h hashmap.h
+)
+
+foreach (build_dir IN LISTS BUILD_DIRS TEMPLATE_DIRS)
+    file(GLOB TEMP "${build_dir}/*.c")
+    list(APPEND SOURCES ${TEMP})
+    file(GLOB TEMP "${build_dir}/*.h")
+    list(APPEND HEADERS ${TEMP})
+endforeach ()
+
+execute_process(
+    COMMAND ${PYTHON_EXECUTABLE} -c 
+"
+from os.path import join
+
+with open(join('${CMAKE_SOURCE_DIR}','qadic', 'CPimport.txt')) as fin:
+    with open('cpimport.h', 'w+') as fout:
+        while True:
+            l = fin.readline()
+            if not l:
+                break
+            l = l.replace(' ', ',')
+            l = l.replace('\\n', ',\\n')
+            fout.writelines([l])
+"
+    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
+)
+
+# Configuration checks
+test_big_endian(HAVE_BIG_ENDIAN)
+
+if(NOT HAVE_BIG_ENDIAN)
+    set(HAVE_LITTLE_ENDIAN ON)
+    set(HAVE_DOUBLE_IEEE_LITTLE_ENDIAN ON)
+else()
+    set(HAVE_DOUBLE_IEEE_BIG_ENDIAN ON)
+endif()
+
+# setup for config.h
+check_include_files(alloca.h HAVE_ALLOCA_H)
+check_include_files(dlfcn.h HAVE_DLFCN_H)
+check_include_files(fcntl.h HAVE_FCNTL_H)
+check_include_files(inttypes.h HAVE_INTTYPES_H)
+check_include_files(locale.h HAVE_LOCALE_H)
+check_include_files(memory.h HAVE_MEMORY_H)
+check_include_files(sstream HAVE_SSTREAM)
+check_include_files(stdint.h HAVE_STDINT_H)
+check_include_files(stdlib.h HAVE_STDLIB_H)
+check_include_files(strings.h HAVE_STRINGS_H)
+check_include_files(string.h HAVE_STRING_H)
+check_include_files(sys/mman.h HAVE_SYS_MMAN_H)
+check_include_files(sys/param.h HAVE_SYS_PARAM_H)
+check_include_files(sys/processor.h HAVE_SYS_PROCESSOR_H)
+check_include_files(sys/resource.h HAVE_SYS_RESOURCE_H)
+check_include_files(sys/stat.h HAVE_SYS_STAT_H)
+check_include_files(sys/sysctl.h HAVE_SYS_SYSCTL_H)
+check_include_files(sys/syssgi.h HAVE_SYS_SYSSGI_H)
+check_include_files(sys/systemcfg.h HAVE_SYS_SYSTEMCFG_H)
+check_include_files(sys/times.h HAVE_SYS_TIMES_H)
+check_include_files(sys/time.h HAVE_SYS_TIME_H)
+check_include_files(sys/types.h HAVE_SYS_TYPES_H)
+check_include_files(unistd.h HAVE_UNISTD_H)
+check_include_files(dlfcn.h HAVE_DLFCN_H)
+check_include_files(fpu_control.h HAVE_FPU_CONTROL_H)
+
+
+check_function_exists(alloca HAVE_ALLOCA)
+check_function_exists(alarm HAVE_ALARM)
+check_function_exists(clock HAVE_CLOCK)
+check_function_exists(clock_gettime HAVE_CLOCK_GETTIME)
+check_function_exists(cputime HAVE_CPUTIME)
+check_function_exists(fgetc HAVE_DECL_FGETC)
+check_function_exists(fscanf HAVE_DECL_FSCANF)
+check_function_exists(optarg HAVE_DECL_OPTARG)
+check_function_exists(ungetc HAVE_DECL_UNGETC)
+check_function_exists(vfprintf HAVE_DECL_VFPRINTF)
+check_function_exists(getpagesize HAVE_GETPAGESIZE)
+check_function_exists(getrusage HAVE_GETRUSAGE)
+check_function_exists(gettimeofday HAVE_GETTIMEOFDAY)
+
+
+configure_file(
+    config.h.in
+    config.h
+)
+
+set(MEMORY_MANAGER "reentrant" CACHE STRING "The FLINT memory manager.")
+set_property(CACHE MEMORY_MANAGER PROPERTY STRINGS single reentrant gc)
+
+configure_file(
+    fmpz-conversions-${MEMORY_MANAGER}.in
+    fmpz-conversions.h
+    COPYONLY
+)
+
+configure_file(
+    fmpz/link/fmpz_${MEMORY_MANAGER}.c
+    fmpz/fmpz.c
+    COPYONLY
+)
+
+if(CMAKE_SIZEOF_VOID_P EQUAL 8)
+    configure_file(
+        fft_tuning64.in
+        fft_tuning.h
+        COPYONLY
+    )   
+elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)
+    configure_file(
+        fft_tuning32.in
+        fft_tuning.h
+        COPYONLY
+    )
+endif()
+
+
+set(TEMP ${HEADERS})
+set(HEADERS )
+foreach(header IN LISTS TEMP)
+    if(EXISTS ${CMAKE_SOURCE_DIR}/${header})
+        list(APPEND HEADERS ${header})
+    else()
+        list(APPEND HEADERS ${CMAKE_BINARY_DIR}/${header})  
+    endif()
+endforeach()
+
+file(GLOB TEMP "${CMAKE_SOURCE_DIR}/*.h")
+list(APPEND HEADERS ${TEMP})
+
+add_library(flint ${SOURCES})
+target_link_libraries(flint 
+    ${GMP_LIBRARIES} ${MPFR_LIBRARIES} ${PThreads_LIBRARIES}
+)
+
+# Include directories
+
+target_include_directories(flint PUBLIC 
+    ${CMAKE_CURRENT_SOURCE_DIR} ${GMP_INCLUDE_DIRS} ${MPFR_INCLUDE_DIRS}
+    ${CMAKE_CURRENT_BINARY_DIR} ${PThreads_INCLUDE_DIRS}
+)
+
+
+if(${BUILD_SHARED_LIBS} AND MSVC)
+    target_compile_definitions(flint PRIVATE "MSC_BUILD_DLL")
+endif()
+
+
+if(NOT DEFINED IPO_SUPPORTED)
+    message(STATUS "Checking for IPO")
+    check_ipo_supported(RESULT ipo_supported LANGUAGES C)
+    if(ipo_supported)
+        message(STATUS "Checking for IPO - found")
+    else()
+        message(STATUS "Checking for IPO - not found")
+    endif()
+    set(IPO_SUPPORTED ${ipo_supported} CACHE INTERNAL "Introprocedural Optimization" FORCE)
+endif()
+
+if(IPO_SUPPORTED)
+    set_target_properties(flint PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE)
+endif()
+
+if(NOT MSVC)
+    target_link_libraries(flint m)
+endif()
+
+install(TARGETS flint
+            RUNTIME DESTINATION bin
+            ARCHIVE DESTINATION lib
+            LIBRARY DESTINATION lib
+        )
+
+install(FILES ${HEADERS} DESTINATION include/flint)
+
+set_target_properties(flint
+    PROPERTIES
+    ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib"
+    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib"
+    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
+)
+
+if(MSVC)
+    set_target_properties(flint
+        PROPERTIES
+        LINK_FLAGS "/EXPORT:__flint_clz_tab /EXPORT:flint_primes_small"
+    )
+endif()
+
+if(BUILD_TESTING)
+    enable_testing()
+    add_library(test_helpers STATIC test_helpers.c)
+    target_link_libraries(test_helpers flint)
+
+    foreach (build_dir IN LISTS BUILD_DIRS CMAKE_SOURCE_DIR)
+        file(GLOB TEST_FILES "${build_dir}/test/*.c")
+        foreach(test_file IN LISTS TEST_FILES)
+            file(RELATIVE_PATH test_name ${CMAKE_SOURCE_DIR} ${test_file})
+            string(REPLACE "/" "-" test_name ${test_name})
+            get_filename_component(test_name ${test_name} NAME_WE)
+            add_executable(${test_name} ${test_file})
+            target_link_libraries(${test_name}
+                flint test_helpers
+                ${GMP_LIBRARIES} ${MPFR_LIBRARIES} ${PThreads_LIBRARIES}
+            )
+
+            add_test(
+                NAME ${test_name}
+                COMMAND $<TARGET_FILE:${test_name}>
+            )
+
+            set_target_properties(${test_name}
+                PROPERTIES
+                ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib"
+                LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib"
+                RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
+            )
+        endforeach()
+    endforeach ()
+endif()
diff --git a/config.h.in b/config.h.in
new file mode 100644
index 000000000..c16ca2403
--- /dev/null
+++ b/config.h.in
@@ -0,0 +1,326 @@
+#cmakedefine HAVE_STDINT_H 1
+
+#cmakedefine HAVE_INTTYPES_H 1
+
+#cmakedefine HAVE_LITTLE_ENDIAN 1
+
+/* Define if you have the `alarm' function. */
+#cmakedefine HAVE_ALARM
+
+/* Define if alloca() works (via gmp-impl.h). */
+#cmakedefine HAVE_ALLOCA			1
+
+/* Define if you have <alloca.h> and it should be used (not on Ultrix). */
+#cmakedefine HAVE_ALLOCA_H
+
+/* Define if the compiler accepts gcc style __attribute__ ((const)) */
+#cmakedefine HAVE_ATTRIBUTE_CONST
+
+/* Define if the compiler accepts gcc style __attribute__ ((malloc)) */
+#cmakedefine HAVE_ATTRIBUTE_MALLOC
+
+/* Define if the compiler accepts gcc style __attribute__ ((mode (XX))) */
+#cmakedefine HAVE_ATTRIBUTE_MODE
+
+/* Define if the compiler accepts gcc style __attribute__ ((noreturn)) */
+#cmakedefine HAVE_ATTRIBUTE_NORETURN
+
+/* Define if tests/libtests has calling conventions checking for the CPU */
+#cmakedefine HAVE_CALLING_CONVENTIONS
+
+/* Define if you have the `clock' function. */
+#cmakedefine HAVE_CLOCK			1
+
+/* Define if you have the `clock_gettime' function. */
+#cmakedefine HAVE_CLOCK_GETTIME
+
+/* Define if you have the `cputime' function. */
+#cmakedefine HAVE_CPUTIME
+
+/* Define to 1 if you have the declaration of `fgetc', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_FGETC		1
+
+/* Define to 1 if you have the declaration of `fscanf', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_FSCANF	1
+
+/* Define to 1 if you have the declaration of `optarg', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_OPTARG	0
+
+/* Define to 1 if you have the declaration of `ungetc', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_UNGETC	1
+
+/* Define to 1 if you have the declaration of `vfprintf', and to 0 if you
+   don't. */
+#cmakedefine HAVE_DECL_VFPRINTF	1
+
+/* Define if denormalized floats work. */
+#cmakedefine HAVE_DENORMS		1
+
+/* Define if you have the <dlfcn.h> header file. */
+#cmakedefine HAVE_DLFCN_H
+
+/* Define one (and only one) of the following for the format of a `double'.
+   If your format is not among these choices, or you don't know what it is,
+   then leave all of them undefined.
+   "IEEE_LITTLE_SWAPPED" means little endian, but with the two 4-byte halves
+   swapped, as used by ARM CPUs in little endian mode.  */
+#cmakedefine HAVE_DOUBLE_IEEE_BIG_ENDIAN
+#cmakedefine HAVE_DOUBLE_IEEE_LITTLE_ENDIAN
+#cmakedefine HAVE_DOUBLE_IEEE_LITTLE_SWAPPED
+#cmakedefine HAVE_DOUBLE_VAX_D
+#cmakedefine HAVE_DOUBLE_VAX_G
+#cmakedefine HAVE_DOUBLE_CRAY_CFP
+
+/* Define if you have the <fcntl.h> header file. */
+#cmakedefine HAVE_FCNTL_H		1
+
+/* Define if you have the <fpu_control.h> header file. */
+#cmakedefine HAVE_FPU_CONTROL_H
+
+/* Define if you have the `getpagesize' function. */
+#cmakedefine HAVE_GETPAGESIZE
+
+/* Define if you have the `getrusage' function. */
+#cmakedefine HAVE_GETRUSAGE
+
+/* Define if you have the `gettimeofday' function. */
+#cmakedefine HAVE_GETTIMEOFDAY
+
+/* Define if 0/0, 1/0, -1/0 and sqrt(-1) work to generate NaN/infinities. */
+#cmakedefine HAVE_INFS			1
+
+/* Define if the system has the type `intmax_t'. */
+#cmakedefine HAVE_INTMAX_T
+
+/* Define one (just one) of the following for the endiannes of `mp_limb_t'.
+   If the endianness is not a simple big or little, or you don't know what
+   it is, then leave both of these undefined. */
+#cmakedefine HAVE_LIMB_BIG_ENDIAN
+#cmakedefine HAVE_LIMB_LITTLE_ENDIAN		1
+
+#cmakedefine HAVE_STD__LOCALE 1
+
+/* Define if you have the `localeconv' function. */
+#cmakedefine HAVE_LOCALECONV		1
+
+/* Define if you have the <locale.h> header file. */
+#cmakedefine HAVE_LOCALE_H		1
+
+/* now required by MPFR */
+#cmakedefine HAVE_STRUCT_LCONV_DECIMAL_POINT 1
+#cmakedefine HAVE_STRUCT_LCONV_THOUSANDS_SEP 1
+
+/* Define if the system has the type `long double'. */
+#cmakedefine HAVE_LONG_DOUBLE	1
+
+/* Define if the system has the type `long long'. */
+#cmakedefine HAVE_LONG_LONG		1
+
+/* Define if you have the `lrand48' function. */
+#cmakedefine HAVE_LRAND48
+
+/* Define if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H		1
+
+/* Define if you have the `memset' function. */
+#cmakedefine HAVE_MEMSET			1
+
+/* Define if you have the `mmap' function. */
+#cmakedefine HAVE_MMAP
+
+/* Define if you have the `mprotect' function. */
+#cmakedefine HAVE_MPROTECT
+
+/* Define if you have the `obstack_vprintf' function. */
+#cmakedefine HAVE_OBSTACK_VPRINTF
+
+/* Define if you have the `popen' function. */
+#cmakedefine HAVE_POPEN
+
+/* Define if you have the `processor_info' function. */
+#cmakedefine HAVE_PROCESSOR_INFO
+
+/* Define if the system has the type `ptrdiff_t'. */
+#cmakedefine HAVE_PTRDIFF_T		1
+
+/* Define if the system has the type `quad_t'. */
+#cmakedefine HAVE_QUAD_T
+
+#cmakedefine HAVE_RAISE			1
+
+/* Define if you have the `read_real_time' function. */
+#cmakedefine HAVE_READ_REAL_TIME
+
+#cmakedefine HAVE_SIGNAL         1
+#cmakedefine HAVE_SIGNAL_H       1
+
+/* Define if you have the `sigaction' function. */
+#cmakedefine HAVE_SIGACTION
+
+/* Define if you have the `sigaltstack' function. */
+#cmakedefine HAVE_SIGALTSTACK
+
+/* Define if you have the `sigstack' function. */
+#cmakedefine HAVE_SIGSTACK
+
+/* Tune directory speed_cyclecounter, undef=none, 1=32bits, 2=64bits) */
+#cmakedefine HAVE_SPEED_CYCLECOUNTER	2
+
+/* Define if the system has the type `stack_t'. */
+#cmakedefine HAVE_STACK_T
+
+/* Define if <stdarg.h> exists and works */
+#cmakedefine HAVE_STDARG			1
+
+/* Define if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H		1
+
+/* Define if you have the `strcasecmp' function. */
+#cmakedefine HAVE_STRCASECMP
+
+/* Define if you have the `strchr' function. */
+#cmakedefine HAVE_STRCHR			1
+
+/* Define if cpp supports the ANSI # stringizing operator. */
+#cmakedefine HAVE_STRINGIZE		1
+
+/* Define if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H
+
+/* Define if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H		1
+
+/* Define if you have the `strnlen' function. */
+#cmakedefine HAVE_STRNLEN        1
+
+/* Define if you have the `strtoul' function. */
+#cmakedefine HAVE_STRTOUL		1
+
+/* Define if you have the `sysconf' function. */
+#cmakedefine HAVE_SYSCONF
+
+/* Define if you have the `sysctl' function. */
+#cmakedefine HAVE_SYSCTL
+
+/* Define if you have the `sysctlbyname' function. */
+#cmakedefine HAVE_SYSCTLBYNAME
+
+/* Define if you have the `syssgi' function. */
+#cmakedefine HAVE_SYSSGI
+
+/* Define if you have the <sys/mman.h> header file. */
+#cmakedefine HAVE_SYS_MMAN_H
+
+/* Define if you have the <sys/param.h> header file. */
+#cmakedefine HAVE_SYS_PARAM_H
+
+/* Define if you have the <sys/processor.h> header file. */
+#cmakedefine HAVE_SYS_PROCESSOR_H
+
+/* Define if you have the <sys/resource.h> header file. */
+#cmakedefine HAVE_SYS_RESOURCE_H
+
+/* Define if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H		1
+
+/* Define if you have the <sys/sysctl.h> header file. */
+#cmakedefine HAVE_SYS_SYSCTL_H
+
+/* Define if you have the <sys/syssgi.h> header file. */
+#cmakedefine HAVE_SYS_SYSSGI_H
+
+/* Define if you have the <sys/systemcfg.h> header file. */
+#cmakedefine HAVE_SYS_SYSTEMCFG_H
+
+/* Define if you have the <sys/times.h> header file. */
+#cmakedefine HAVE_SYS_TIMES_H
+
+/* Define if you have the <sys/time.h> header file. */
+#cmakedefine HAVE_SYS_TIME_H
+
+/* Define if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H	1
+
+/* Define if you have the `times' function. */
+#cmakedefine HAVE_TIMES
+
+/* Define if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H
+
+/* Define if you have vsnprintf and it works properly. */
+#cmakedefine HAVE_VSNPRINTF
+
+/* Assembler local label prefix */
+#cmakedefine LSYM_PREFIX
+
+/* Define if you have the `fesetround' function via the <fenv.h> header file.
+   */
+#cmakedefine MPFR_HAVE_FESETROUND
+
+#cmakedefine HAVE_SSTREAM 1
+
+/* Define if compiler has function prototypes */
+#cmakedefine PROTOTYPES			1
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#cmakedefine RETSIGTYPE	void
+
+/* The size of a `unsigned long', as computed by sizeof. */
+#cmakedefine SIZEOF_UNSIGNED_LONG	4
+
+/* Define if sscanf requires writable inputs */
+#cmakedefine SSCANF_WRITABLE_INPUT
+
+/* Define if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS		1
+
+/* ./configure --enable-assert option, to enable some ASSERT()s */
+#cmakedefine WANT_ASSERT
+
+/* Define if your processor stores words with the most significant byte first
+   (like Motorola and SPARC, unlike Intel and VAX). */
+#cmakedefine WORDS_BIGENDIAN
+
+#cmakedefine HAVE_PTHREAD 1
+
+/* Define as `__inline' if that's what the C compiler calls it, or to nothing
+   if it is not supported. */
+#ifndef __cplusplus
+#define inline	__inline
+#endif
+
+#ifdef HAVE_STDINT_H
+#define HAVE_INTMAX_T        1
+#define HAVE_UINTMAX_T       1
+#define HAVE_PTRDIFF_T       1
+#define HAVE_UINT_LEAST32_T  1
+#define SIZEOF_UINTMAX_T	 8
+#endif
+
+#define NPRINTF_J            1
+#define NPRINTF_T            1
+
+#ifdef _MSC_VER
+#define access _access
+#define strcasecmp _stricmp
+#define strncasecmp	_strnicmp
+#define alloca _alloca
+#define HAVE_STRCASECMP		1
+#define HAVE_STRNCASECMP	1
+#define MSC_C_(x) #x  
+#define MSC_CC_(x)  MSC_C_(x)
+#define MSC_VERSION "Microsoft C++ (Version " MSC_CC_(_MSC_FULL_VER) ")"
+
+#endif
+
+#if defined (MSC_BUILD_DLL)
+#define FLINT_DLL __declspec(dllexport)
+#elif defined(MSC_USE_DLL)
+#define FLINT_DLL __declspec(dllimport)
+#else
+#define FLINT_DLL
+#endif
diff --git a/gettimeofday.c b/gettimeofday.c
new file mode 100644
index 000000000..5a104797c
--- /dev/null
+++ b/gettimeofday.c
@@ -0,0 +1,39 @@
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <time.h>
+
+#include "gettimeofday.h"
+
+int gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+    FILETIME        ft;
+    LARGE_INTEGER   li;
+    __int64         t;
+    static int      tzflag;
+
+    if(tv)
+    {
+        GetSystemTimeAsFileTime(&ft);
+        li.LowPart  = ft.dwLowDateTime;
+        li.HighPart = ft.dwHighDateTime;
+        t  = li.QuadPart; 
+        t -= EPOCHFILETIME;
+        t /= 10;
+        tv->tv_sec  = (long)(t / 1000000);
+        tv->tv_usec = (long)(t % 1000000);
+    }
+
+    if (tz)
+    {
+        if (!tzflag)
+        {
+            _tzset();
+            tzflag++;
+        }
+        tz->tz_minuteswest = _timezone / 60;
+        tz->tz_dsttime = _daylight;
+    }
+
+    return 0;
+}
diff --git a/gettimeofday.h b/gettimeofday.h
new file mode 100644
index 000000000..a211450d1
--- /dev/null
+++ b/gettimeofday.h
@@ -0,0 +1,34 @@
+/*
+ * timeval.h    1.0 01/12/19
+ *
+ * Defines gettimeofday, timeval, etc. for Win32
+ *
+ * By Wu Yongwei
+ *
+ */
+#ifndef _TIMEVAL_H
+#define _TIMEVAL_H
+
+#include <winsock2.h>
+
+#define EPOCHFILETIME (116444736000000000LL)
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+struct timezone 
+{
+    int tz_minuteswest; /* minutes W of Greenwich */
+    int tz_dsttime;     /* type of dst correction */
+};
+
+int gettimeofday(struct timeval *tv, struct timezone *tz);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* _TIMEVAL_H */
+
